#include <bits/stdc++.h>
using namespace std;

int main() {
    

    bitset<ビット数> 変数名;  // すべてのビットが0の状態で初期化される
    bitset<8> b("00110101");  // 指定したビット列で初期化される

    // & ビット毎のAND演算	「両方のビットが1ならば1」
    // | ビット毎のOR演算	「少なくとも一方のビットが1ならば1」
    // ^ ビット毎のXOR演算	「どちらか一方だけが1ならば1」
    // ~ ビット毎のNOT演算	「ビットを反転する」
    // << 左シフト演算	指定したビット数だけビット列を左にずらす。範囲外のビットは切り捨てられ、足りないビットは0で埋められる。
    // >> 右シフト演算	指定したビット数だけビット列を右にずらす。範囲外のビットは切り捨てられ、足りないビットは0で埋められる。

    // AND AND演算　ビット列に対してAND
    // OR OR演算　ビット列に対してOR
    // XOR XOR演算　ビット列に対してXOR
    // NOT NOT演算　ビット列に対してNOT

    //全てのビットを1にする	変数.set();	
    //特定のビットを1にする	変数.set(1にする位置);	1にするビットの位置を0始まりのインデックスで指定します。
    //特定のビットの値を変更する	変数.set(位置, 値);	変更するビットの位置を0始まりのインデックスで指定します。値は0か1を指定します。
    //全てのビットを0にする	変数.reset();	
    //特定のビットを0にする	変数.reset(0にする位置);	0にするビットの位置を0始まりのインデックスで指定します。
    //全てのビットを反転する	変数.flip();	
    //特定のビットを反転する	変数.flip(反転する位置);	反転するビットの位置を0始まりのインデックスで指定します。
    //特定のビットが1になっているかを調べる	変数.test(調べる位置);	調べるビットの位置を0始まりのインデックスで指定します。ビットが1ならtrueを、ビットが0ならfalseを返します。
    //全てのビットが1になっているかを判定する	変数.all()	全てのビットが1ならtrueを、そうでなければfalseを返します。
    //いずれかのビットが1になっているかを判定する	変数.any()	1のビットが存在するならtrueを、そうでなければfalseを返します。
    //1のビットの個数を数える	変数.count()	
    //ビット列を出力する	cout << 変数;	
    //ビット列を文字列化する	変数.to_string()	
    //ビットに対するアクセス	変数[位置]	基本的にはtest、set/resetと同等ですが、範囲外の位置を指定した場合にエラーにならないことに注意する必要があります。

    // 3ビットのビット列をすべて列挙する
    for (int blp = 0; blp < (1 << 3); blp++) {
        bitset<3> s(blp); //数字で指定する必要有り
        // ビット列を出力
        cout << s << endl;
    }

    //bitsetから整数への変換
    //bitsetの変数.to_ullong();

    return 0;
}