# 連結性チェックがスコアに与える影響の考察

## 1. トレント配置数の減少

### 問題点

- `check_full_connectivity`は非常に厳しい条件
- 一つでも孤立する空きマスが生まれるとトレント配置を拒否
- 結果として配置できるトレント数が大幅に減少

### 影響

- 視界制限効果が薄くなる
- 冒険者の探索効率が上がってしまう
- 最終的な経路長が短くなる

## 2. 過度に保守的な戦略

### 現在の連結性チェック

```cpp
// 全ての空きマスがスタート地点と連結している必要がある
for (const auto &cell : empty_cells) {
    int cell_component = dsu.leader(coord_to_index(cell.first, cell.second));
    if (cell_component != start_component) {
        return false; // 一つでも孤立があると失敗
    }
}
```

### 問題

- 実際には冒険者が訪れない可能性の高い遠い場所まで考慮
- 花への経路さえ確保されていれば十分なのに、全空間の連結性を要求

## 3. 計算コストの増加

### パフォーマンス面

- DSU による連結性チェックは各トレント配置候補に対して実行
- O(N²)の空きマス × DSU 処理 = 重い計算
- 実行時間制限内での最適化機会を逸している

## 4. 代替案の検討

### より緩い連結性チェック

1. **花への経路のみチェック**: `calculate_path_length`で十分
2. **局所的な孤立のみ防止**: 周囲の小さな空きマス群の分離を防ぐ
3. **確率的な配置**: 一定確率で連結性を無視してトレントを配置

### 実装例

```cpp
// より緩い連結性チェック（花への経路のみ）
bool check_minimal_connectivity(const vector<string> &maze, int pi, int pj) {
    return calculate_path_length(pi, pj, ti, tj, maze) != -1;
}
```

## 5. 結論

連結性チェックは理論的には正しいが、この問題においては：

- **過度に制約が厳しい**
- **実用的でない**
- **スコア向上に寄与しない**

むしろ**貪欲にトレントを配置**し、**花への経路のみ確保**する方が効果的。
